# 6.12. Время связывания переменных
# ----------------НЕМНОГО ТЕОРИИ-------------------------------------#
# Python - это интрапретируемый язык программирования. 
# Исходный код частями преобразуется в машинный в процессе выполнения специальной программой (интропретатором).
# При этом существует 2 вида интропретатора: 
#  - Простой интерпретатор. Он берет одну инструкцию, транслирует и сразу выполняет ее, а затем берет следующую инструкцию.
#  - Интерпретатор компилирующего типа. Это система из компилятора и интерпретатора. Компилятор переводит исходный код программы в промежуточное представление (байт-код), а интерпретатор (виртуальная машина) выполняет этот байт-код.
# Переменные не нуждаются в объявлении для резервирования места в памяти. 
# Инициация* происходит автоматически, когда мы присваиваем значение переменной.
# * под инициацией в Python понимаем установку ссылки на объект значения
# -------------------------------------------------------------------#
# У меня установлен CPython (Интерпретатор компилирующего типа)

# 1. Пример связывания переменных distance и previous_time во время написания кода.
# Данный способ выбран т.к. необходимо задать первоначальное значение для корректного расчета следующих значений
def odometer(oksana): # Поездка на мотоцикле
    # много кода
    distance = 0  # Расстояние
    previous_time = 0  # Предыдущее время с начала поездки
    for i in range(1, N, 2):
        distance += (oksana[i-1]) * (oksana[i] - previous_time) # скорость * время поездки с этой скоростью
        previous_time = oksana[i] # Запоминаем пред.время
    # много кода

# 2. Ссылка на объект "01.07.2021" для переменной DATA устнавливается во время написания кода, 
# а ссылка на объект "01.07.2021" для переменнной Data_end устанавливается во время компиляции.
# Данный способ выбран т.к. он позволяет использовать DATA как константу и, при необходимости, изменить DATA, не меняя весь код. 
    DATA = "01.07.2021"
    # много кода
    Data_end = DATA

# 3. Пример связывания переменной self.alias во время выполнения программы. 
# Данный способ выбран т.к. необходимо считать вводимое пользователем значение
class Client(socket.socket): # Инициализируем отсновные параметры клиента
    def __init__(self):
        super(Client, self).__init__(socket.AF_INET, socket.SOCK_STREAM)
        self.connect(('localhost', 12345))
        self.alias = input('Введите имя: ')
        self.send((self.alias + ' Connect to server').encode('utf-8'))